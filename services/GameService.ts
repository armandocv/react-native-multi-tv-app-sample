// services/GameService.ts
import { get, post } from 'aws-amplify/api';
import { fetchAuthSession } from 'aws-amplify/auth';

export interface Game {
  sgId: string;
  appId: string;
  name: string;
  description: string;
  preview: string;
  ordering: number;
  regions?: string[];
  staticTile: boolean;
  supportedInputs: string[];
}

export interface StreamSession {
  arn: string;
  region?: string;
  status?: string;
  signalResponse?: string;
  error?: string;
}

/**
 * Fetches the list of available games from the API
 */
export const getGames = async (): Promise<Game[]> => {
  try {
    // Get current session to ensure we have a valid token
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    
    const response = await get({
      apiName: 'gamelift-api',
      path: '/games',
      options: {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    }).response;
    
    const data = await response.body.json();
    const games = data as Game[];
    
    // Sort games by ordering and name
    return games.sort((g1, g2) => {
      if (g1.ordering === g2.ordering) {
        return g1.name.localeCompare(g2.name);
      } else {
        return g1.ordering - g2.ordering;
      }
    });
  } catch (error) {
    console.error('Error fetching games:', error);
    // Enhanced error logging
    if (error.response) {
      console.error('API response error:', error.response.status, error.response.data);
    } else {
      console.error('API call failed with error:', error.message);
    }
    throw error;
  }
};

/**
 * Creates a new stream session using the GameLift Streams API
 * 
 * @param appId - The application identifier
 * @param sgId - The stream group identifier
 * @param signalRequest - The WebRTC signal request generated by the GameLift Streams SDK
 * @param regions - Array of AWS regions to try for streaming
 * @returns Promise with the session ARN
 */
export const createStreamSession = async (
  appId: string, 
  sgId: string, 
  signalRequest: string,
  regions: string[]
): Promise<StreamSession> => {
  try {
    // Get current session to ensure we have a valid token
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    
    console.log(`Creating stream session for app ${appId}, group ${sgId} in regions: ${regions.join(', ')}`);
    
    const payload = {
      AppIdentifier: appId,
      SGIdentifier: sgId,
      UserId: 'DefaultUser', // In production, use actual user ID
      SignalRequest: signalRequest || null, // Allow empty signal request for initial creation
      Regions: regions
    };

    const response = await post({
      apiName: 'gamelift-api',
      path: '/',
      options: {
        body: payload,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    }).response;

    const data = await response.body.json();
    console.log('Stream session created:', data);
    return data;
  } catch (error) {
    console.error('Error creating stream session:', error);
    // Enhanced error logging
    if (error.response) {
      console.error('API response error:', error.response.status, error.response.data);
    }
    throw error;
  }
};

/**
 * Polls for the status of a stream session
 * 
 * @param sgId - The stream group identifier
 * @param arn - The session ARN
 * @returns Promise with the session status
 */
export const getSessionStatus = async (sgId: string, arn: string): Promise<StreamSession> => {
  try {
    // Get current session to ensure we have a valid token
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    
    console.log(`Checking status for session ${arn} in group ${sgId}`);
    
    const response = await get({
      apiName: 'gamelift-api',
      path: `/session/${encodeURIComponent(sgId)}/${encodeURIComponent(arn)}`,
      options: {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    }).response;

    const data = await response.body.json();
    console.log('Session status:', data);
    return data;
  } catch (error) {
    console.error('Error checking session status:', error);
    // Enhanced error logging
    if (error.response) {
      console.error('API response error:', error.response.status, error.response.data);
    }
    throw error;
  }
};

/**
 * Updates an existing stream session with a signal request
 * 
 * @param sgId - The stream group identifier
 * @param arn - The session ARN
 * @param signalRequest - The WebRTC signal request generated by the GameLift Streams SDK
 * @returns Promise with the update result
 */
export const updateStreamSession = async (
  sgId: string,
  arn: string,
  signalRequest: string
): Promise<any> => {
  try {
    // Get current session to ensure we have a valid token
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    
    console.log(`Updating stream session ${arn} in group ${sgId} with signal request`);
    
    const response = await post({
      apiName: 'gamelift-api',
      path: `/session/${encodeURIComponent(sgId)}/${encodeURIComponent(arn)}/update`,
      options: {
        body: {
          SignalRequest: signalRequest
        },
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    }).response;

    const data = await response.body.json();
    console.log('Stream session updated:', data);
    return data;
  } catch (error) {
    console.error('Error updating stream session:', error);
    // Enhanced error logging
    if (error.response) {
      console.error('API response error:', error.response.status, error.response.data);
    }
    throw error;
  }
};
/**
 * Terminates an active stream session
 * 
 * @param sgId - The stream group identifier
 * @param arn - The session ARN
 * @returns Promise with the termination result
 */
export const terminateStreamSession = async (sgId: string, arn: string): Promise<any> => {
  try {
    // Get current session to ensure we have a valid token
    const session = await fetchAuthSession();
    const token = session.tokens?.idToken?.toString();
    
    console.log(`Terminating session ${arn} in group ${sgId}`);
    
    const response = await post({
      apiName: 'gamelift-api',
      path: `/session/${encodeURIComponent(sgId)}/${encodeURIComponent(arn)}/terminate`,
      options: {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    }).response;

    const data = await response.body.json();
    console.log('Session terminated:', data);
    return data;
  } catch (error) {
    console.error('Error terminating session:', error);
    // Enhanced error logging
    if (error.response) {
      console.error('API response error:', error.response.status, error.response.data);
    }
    throw error;
  }
};
